<html>
<head>
<script src="math.js" type="text/javascript"></script>
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
.item { 
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    user-select: none;
}
div {
width: 100%; 
height: 100%;
padding: 0;
margin:0;
position: absolute; 
top: 0; 
right: 0; 
bottom: 0; 
left: 0;} 
* { margin:0; padding:0; }
</style>

</head>
<body onload="perceptron()" bgcolor="#000">
<canvas id="canvas" width="1" height="1">Sorry, your browser does not support JavaScript canvas, or it is disabled.</canvas>
<script type="application/javascript">

/** As far a I can tell this is how you do println in Javascript? */
function print(msg){setTimeout(function(){throw new Error(msg);},0);}

function perceptron(){
    print('loading');

    var MAPFIXEDP = 16;
    var W  = window.innerWidth;//640;
    var H  = window.innerHeight;//480;
    var W2 = W/2;
    var H2 = H/2;
	var Wx2 = W*2;
	var Hx2 = H*2;
    print(W);
    print(H);
    var CMASK = 0xf0f0f0;

    /* prepare canvas */
    var canvas = document.getElementById('canvas');
    canvas.width  = W; 
    canvas.height = H; 
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0,0,W,H);
    canvas.onselectstart = function(){return false;}
    canvas.className = "item"
	
	var colormap=new Uint32Array(256);
	for(var i=0;i<256;i++){
	    var hue=6.0*i/256;
	    var r=0;
	    var g=0;
	    var b=0;
	    var C=255;
	    if (hue<1)    { r+=C;g+=C*hue; }
        else if(hue<2){ r+=C*(2-hue); g+=C; }
        else if(hue<3){ g+=C; b+=C*(hue-2); }
        else if(hue<4){ g+=C*(4-hue); b+=C; }
        else if(hue<5){ r+=C*(hue-4); b+=C; }
        else          { r+=C; b+=C*(6-hue); }
        r=Math.round(r);
        g=Math.round(g);
        b=Math.round(b);
        colormap[i]=(((r<<16)|(g<<8)|b)&CMASK);
    }
	
    var buff1 = new Uint32Array( W*H + 1);
    var buff2 = new Uint32Array( W*H + 1);         
    var buf  = new ArrayBuffer(imageData.data.length);
    var buf8 = new Uint8ClampedArray(buf);
    var data = new Uint32Array(buf);
    
    var huetic = 0;
    
    /* We seed a weak RNG with a strong RNG. This gives us good speed
     and also decent randomness */
    var rand = Math.floor(Math.random()*0x1000000);
	
    for (var y = 0; y < H; ++y) {
	    for (var x = 0; x < W; ++x) {
			rand ^= rand>>2^rand<<1;
	    	//buff1[x+y*W] = (rand&1);
		}
	}
	
	var running = true;
	var downX = null; 
	var downY = null;
	
    var buffPrev = new Uint32Array(W);
    var buffCurr = new Uint32Array(W);
    var buffNext = new Uint32Array(W);
	
    function render() {
        /* We seed a weak RNG with a strong RNG. This gives us good speed
         and also decent randomness */
        var rand = Math.floor(Math.random()*0x1000000);
		
		/*
		     0
		[p|c|n]
		     0 1
		[p|c|n| ]
		   p|c|n

		/* compute col 3-sums */
        for (var x=0; x<W; ++x) {
			var prev = buff1[x+W*(H-2)];
			var curr = buff1[x+W*(H-1)];
			var next = buff1[x];
			var sums = prev+curr+next;
	        for (var y=0; y<H; ++y) {
				sums-= prev;
				prev = curr;
				curr = next;
				next = buff1[(y<H-1?y+1:0)*W+x];
				sums+= next;
				buff2[x+W*y]=sums;
			}
		}
        var writeindex = 0;
		var changed = false;
		/* compute row 3-sums */
        for (var y=0; y<H; ++y) {
			var i = W*y;
			var prev = buff2[i+W-2];
			var curr = buff2[i+W-1];
			var next = buff2[i];
			var sums = prev+curr+next;
	        for (var x=0; x<W; ++x) {
	            writeindex = y*W+x;
				sums-= prev;
				prev = curr;
				curr = next;
				next = buff2[(x<W-1?x+1:0)+i];
				sums+= next;
				//if (!sums) continue;
					
				var color = buff1[x+W*y];
				if (sums==3) color=1;
				else if (color&&sums!=4) color=0;
				
				if (color) data[writeindex] = ~0;
				else data[writeindex] = 0xff000000|((data[writeindex]&0xf0f0f0)*15>>4);
	            buff1[writeindex] = color;
	        }
		}
        
        /* blit to screen */
        imageData.data.set(buf8);
        ctx.putImageData(imageData,0,0);
        
		/* flip drawing buffers */
        //var temp = buff2;
        //buff2 = buff1;
        //buff1 = temp;
        
        /** Apparently animations loops live in the event thread like so*/
        if (running) setTimeout(render, 0);
    }
	
	document.onmousemove = function(e) {
		if (!running) return;
		var x = e.pageX;//-canvas.offsetLeft;
		var y = e.pageY;//-canvas.offsetTop;
        var rand = Math.floor(Math.random()*0x1000000);
		for (var xi=-1; xi<=1; xi++)
		for (var yi=-1; yi<=1; yi++) {
			var xj=x+xi;
			var yj=y+yi;
			yj=yj<0?0:yj>=H?H-1:yj;
			xj=xj<0?0:xj>=W?W-1:xj;
			rand ^= rand>>2^rand<<1;
			buff1[xj+W*yj]=rand&1;
		}
	}
    
	
	document.onmousedown = function(e) {
		downX = e.pageX;
		downY = e.pageY;
		
	}
	document.onclick = function(e) {
		if (downX==e.pageX && downY==e.pageY) {
			if (running) {
				running=false;
				print('stopping');
			}
			else {
				running=true;
	    		setTimeout(render,0);
				print('starting');
			}
		}
	}
	
    print('starting');
    /** Apparently animations loops live in the event thread like so*/
    setTimeout(render, 0);
}

</script>

</body>
</html>
