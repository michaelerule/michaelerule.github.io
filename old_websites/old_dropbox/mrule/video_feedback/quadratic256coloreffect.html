<html>
<head>

<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
.item { 
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    user-select: none;
}
</style>

</head>
<body onload="perceptron()">
<a href="index.html">&#8606; </a></br>
<center>
<canvas id="canvas" width="1" height="1">Sorry, your browser does not support JavaScript canvas, or it is disabled.</canvas>
</center>

<script type="application/javascript">

/** As far a I can tell this is how you do println in Javascript? */
function print(msg){setTimeout(function(){throw new Error(msg);},0);}

function perceptron(){
    var ORDER = 10;
    var N  = 1<<ORDER; /* Screen size */
    var N2 = N/2;
    var MAPFIXEDP = 16;
    var MASK = N-1;

    /* prepare canvas */
    var canvas = document.getElementById('canvas');
    canvas.width  = N; 
    canvas.height = N; 
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, N, N);
    canvas.onselectstart = function(){return false;}
    canvas.className = "item"

    /* prepare cursors */
    cursor_radius = 10;
    var cursor1 = document.createElement("div");
    document.body.appendChild(cursor1);
    cursor1.style='border-radius:50%;background:#0F0;position:absolute;'
    cursor1.style.width  = 2*cursor_radius;
    cursor1.style.height = 2*cursor_radius;
    cursor1.style.top    = canvas.offsetTop+N2;
    cursor1.style.left   = canvas.offsetLeft+N2;
    cursor1.onselectstart = function(){return false;}
    cursor1.className = "item"
    var cursor2 = document.createElement("div");
    document.body.appendChild(cursor2);
    cursor2.style='border-radius:50%;background:#F00;position:absolute;'
    cursor2.style.width  = 2*cursor_radius;
    cursor2.style.height = 2*cursor_radius;
    cursor2.style.top    = canvas.offsetTop+100;
    cursor2.style.left   = canvas.offsetLeft+N2;
    cursor2.onselectstart = function(){return false;}
    cursor2.className = "item"
    
    /* Prepare cursor interactivity hooks */
    var cursor_selected = null;
	document.onmouseup  = function(e) {cursor_selected = null;}
    cursor1.onmousedown = function(e) {cursor_selected = cursor1;}
    cursor2.onmousedown = function(e) {cursor_selected = cursor2;}
	document.onmousemove = function(e) {
		if (cursor_selected) {
			var x = e.clientX-canvas.offsetLeft;
			var y = e.clientY-canvas.offsetTop;
			x = Math.min(N-cursor_radius,x);
			y = Math.min(N-cursor_radius,y);
			x = Math.max(cursor_radius,x);
			y = Math.max(cursor_radius,y);
			cursor_selected.style.top  = y + canvas.offsetTop  - cursor_radius;
			cursor_selected.style.left = x + canvas.offsetLeft - cursor_radius;
		}
	}
	
	var colormap=new Uint32Array(256);
	for(var i=0;i<256;i++){
	    var hue=6.0*i/256;
	    var r=0;
	    var g=0;
	    var b=0;
	    var C=250;
	    if(hue<1){
	        r+=C;g+=C*hue;
        }
        else if(hue<2){
            r+=C*(2-hue);
            g+=C;
        }
        else if(hue<3){
            g+=C;
            b+=C*(hue-2);
        }
        else if(hue<4){
            g+=C*(4-hue);
            b+=C;
        }
        else if(hue<5){
            r+=C*(hue-4);
            b+=C;
        }
        else{
            r+=C;
            b+=C*(6-hue);
        }
        r=Math.round(r);
        g=Math.round(g);
        b=Math.round(b);
        colormap[i]=0xff000000|(((r<<16)|(g<<8)|b)&0xfefefe);
    }
	
    /* prepare recurrence map */
    var map  = new Int32Array( N*N*2 );
    for (var y = 0; y < N; ++y) {
        for (var x = 0; x < N; ++x) {
            var real   = (x-N2)*4.0/N;
            var imag   = (y-N2)*4.0/N;
            var real2  = 0.5*(real*real-imag*imag);
            var imag2  = 0.5*(2*real*imag);
            var x2     = Math.round((real2*N/4+N2)*MAPFIXEDP);
            var y2     = Math.round((imag2*N/4+N2)*MAPFIXEDP);
            var index  = y*N + x;
            /* Note: we subtract an 8-bit fixed point version of N from 
            the coodinates in order to put the origin at the center of 
            the canvas. This allows us to rotate these coordinates 
            without additional shifts beforehand */
            map[index*2  ] = x2-N2*MAPFIXEDP;
            map[index*2+1] = y2-N2*MAPFIXEDP;
        }
    }
    var buff1 = new Uint32Array( N*N + 1);
    var buff2 = new Uint32Array( N*N + 1);

    offsetx  = 0;
    offsety  = 0;
    costheta = 0;
    sintheta = 0;
        
    noise_level = 2;
	noise_beta  = noise_level;
	noise_alpha = 16 - noise_beta;
		
    var buf  = new ArrayBuffer(imageData.data.length);
    var buf8 = new Uint8ClampedArray(buf);
    var data = new Uint32Array(buf);
    
    var huetic = 0;
    
    function render() {
        
        /* Load the cursor locations and set the camera parameters 
        accordingly*/
        y1 = cursor1.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x1 = cursor1.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        offsetx = -x1*16;
        offsety = -y1*16;
        
        y2 = cursor2.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x2 = cursor2.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        mouseTheta  = Math.atan2(x2,y2);
        mouseRadius = Math.round(256*256/Math.sqrt(x2*x2+y2*y2));/* what is this for? */
        costheta    = Math.cos(mouseTheta)*mouseRadius;
        sintheta    = Math.sin(mouseTheta)*mouseRadius;
        
        /* We seed a weak RNG with a strong RNG. This gives us good speed
         and also decent randomness */
        var rand = Math.floor(Math.random()*0x1000000);
        
        var writeindex = 0;
        for (var y = 0; y < N; ++y)
        for (var x = 0; x < N; ++x) {
            var index  = y*N + x;
            var x2 = map[index*2  ] + offsetx;
            var y2 = map[index*2+1] + offsety;
            /* Using 8-bit fixed point, apply a rotation to x2 and y2 */
            /* After the rotation, apply the offset */
            var x3 = (costheta * x2 + sintheta * y2 >> 8) + N2*MAPFIXEDP;
            var y3 = (costheta * y2 - sintheta * x2 >> 8) + N2*MAPFIXEDP;
            var xi = x3>>4;
            var yi = y3>>4;
            var xf = x3 & 0xf;
            var yf = y3 & 0xf;
            /*var index = xi+yi*N;*/
            var x_sign = ((xi>>ORDER)&1)*MASK;
            var y_sign = ((yi>>ORDER)&1)*MASK;
            var xj = (xi&MASK)^x_sign;
            var yj = (yi&MASK)^y_sign;
            var colorA = buff1[(xj+yj*N)];
            xi += 1;
            var x_sign = ((xi>>ORDER)&1)*MASK;
            var y_sign = ((yi>>ORDER)&1)*MASK;
            var xj = (xi&MASK)^x_sign;
            var yj = (yi&MASK)^y_sign;
            var colorB = buff1[(xj+yj*N)];
            yi += 1;
            var x_sign = ((xi>>ORDER)&1)*MASK;
            var y_sign = ((yi>>ORDER)&1)*MASK;
            var xj = (xi&MASK)^x_sign;
            var yj = (yi&MASK)^y_sign;
            var colorD = buff1[(xj+yj*N)];
            xi -= 1;
            var x_sign = ((xi>>ORDER)&1)*MASK;
            var y_sign = ((yi>>ORDER)&1)*MASK;
            var xj = (xi&MASK)^x_sign;
            var yj = (yi&MASK)^y_sign;
            var colorC = buff1[(xj+yj*N)];
            var colorE = (colorA<<4)+(colorB-colorA)*xf >> 4 & 0xf0f0f0;
            var colorF = (colorC<<4)+(colorD-colorC)*xf >> 4 & 0xf0f0f0;
            var color  = (colorE<<4)+(colorF-colorE)*yf >> 4 ;
            //if (xi>=0 && yi>=0 && xi<N && yi<N) {
            
            if (xi>=0 && yi>=0 && xi<N && yi<N) {
                //color >>= 1;
                //color &= 0x7f7f7f;
                //color = (colormap[huetic]+(color&0xfefefe))>>1;
            } 
            else {
                color = (colormap[huetic]+(color&0xfefefe))>>1;
            }
			rand ^= rand>>2^rand<<1;
			color &= 0xf0f0f0;
			color = (color<<4)+((rand&0xf0f0f0)-color)*noise_beta >> 4 & 0xf0f0f0;
			color = 0xff000000|color&0xf0f0f0;
            data[writeindex] = color;
            buff2[writeindex] = color&0xf0f0f0;
            writeindex ++;
        }
        
        /* blit to screen */
        imageData.data.set(buf8);
        ctx.putImageData(imageData, 0, 0);
        
        var temp = buff2;
        buff2 = buff1;
        buff1 = temp;
        
        huetic = (huetic+5)&0xff;
        
        /** Apparently animations loops live in the event thread like so*/
        setTimeout(render, 0);
    }
    
    /** Apparently animations loops live in the event thread like so*/
    setTimeout(render, 0);
}

</script>

</body>
</html>
