<html>
<head>

<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
.item { 
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    user-select: none;
}
</style>

</head>
<body onload="perceptron()" bgcolor="#000">
<a href="index.html">&#8606; </a></br>
<center>
<canvas id="canvas" width="1" height="1"">Sorry, your browser does not support JavaScript canvas, or it is disabled.</canvas>
</center>

<script type="application/javascript">

/** As far a I can tell this is how you do println in Javascript? */
function print(msg){setTimeout(function(){throw new Error(msg);},0);}

function perceptron(){
    print('loading');

    var ORDER = 10;
    var N  = 1<<ORDER; /* Screen size */
    var N2 = N/2;
    var MAPFIXEDP = 16;
    var MASK = N-1;
    
    var W = N;
    var H = N;
    var W2 = W/2;
    var H2 = H/2;

    /* prepare canvas */
    var canvas = document.getElementById('canvas');
    canvas.width  = W; 
    canvas.height = H; 
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0,0,W,H);
    canvas.onselectstart = function(){return false;}
    canvas.className = "item"

    /* prepare cursors */
    cursor_radius = 10;
    var cursor1 = document.createElement("div");
    document.body.appendChild(cursor1);
    cursor1.style = 'border-radius:50%;';
    cursor1.style['border-radius']='50%';
    cursor1.style.background='#0F0';
    cursor1.style.position='absolute';
    cursor1.style.width  = 2*cursor_radius;
    cursor1.style.height = 2*cursor_radius;
    cursor1.style.top    = canvas.offsetTop+H2;
    cursor1.style.left   = canvas.offsetLeft+W2;
    cursor1.onselectstart = function(){return false;}
    cursor1.className = "item"
    
    var cursor2 = document.createElement("div");
    document.body.appendChild(cursor2);
    cursor2.style = 'border-radius:50%;';
    cursor2.style['border-radius']='50%';
    cursor2.style.background='#F00';
    cursor2.style.position='absolute';
    cursor2.style.width  = 2*cursor_radius;
    cursor2.style.height = 2*cursor_radius;
    cursor2.style.top    = canvas.offsetTop+H2/2;
    cursor2.style.left   = canvas.offsetLeft+W2;
    cursor2.onselectstart = function(){return false;}
    cursor2.className = "item"
    
    /* Prepare cursor interactivity hooks */
    var cursor_selected = null;
	document.onmouseup  = function(e) {cursor_selected = null;}
    cursor1.onmousedown = function(e) {cursor_selected = cursor1;}
    cursor2.onmousedown = function(e) {cursor_selected = cursor2;}
	document.onmousemove = function(e) {
		if (cursor_selected) {
			var x = e.pageX-canvas.offsetLeft;
			var y = e.pageY-canvas.offsetTop;
			x = Math.min(N-cursor_radius,x);
			y = Math.min(N-cursor_radius,y);
			x = Math.max(cursor_radius,x);
			y = Math.max(cursor_radius,y);
			cursor_selected.style.top  = y + canvas.offsetTop  - cursor_radius;
			cursor_selected.style.left = x + canvas.offsetLeft - cursor_radius;
			//cursor_selected.style.top  = e.clientY - cursor_radius;
			//cursor_selected.style.left = e.clientX - cursor_radius;
		}
	}
	
	var colormap=new Uint32Array(256);
	for(var i=0;i<256;i++){
	    var hue=6.0*i/256;
	    var r=0;
	    var g=0;
	    var b=0;
	    var C=255;
	    if(hue<1){
	        r+=C;g+=C*hue;
        }
        else if(hue<2){
            r+=C*(2-hue);
            g+=C;
        }
        else if(hue<3){
            g+=C;
            b+=C*(hue-2);
        }
        else if(hue<4){
            g+=C*(4-hue);
            b+=C;
        }
        else if(hue<5){
            r+=C*(hue-4);
            b+=C;
        }
        else{
            r+=C;
            b+=C*(6-hue);
        }
        r=Math.round(r);
        g=Math.round(g);
        b=Math.round(b);
        colormap[i]=(((r<<16)|(g<<8)|b)&0xfcfcfc);
    }
	var ROUNDER = 0x080808;
    /* prepare recurrence map */
    var map  = new Int32Array( N*N*2 );
    for (var y = 0; y < N; ++y) {
        for (var x = 0; x < N; ++x) {
            var real   = (x-N2)*4.0/N;
            var imag   = (y-N2)*4.0/N;
            //var real2  = 0.5*(real*real-imag*imag);
            //var imag2  = 0.5*(2*real*imag);
            var real2  = real;
            var imag2  = imag;
            var x2     = Math.round((real2*N/4+N2)*MAPFIXEDP);
            var y2     = Math.round((imag2*N/4+N2)*MAPFIXEDP);
            var index  = y*N + x;
            /* Note: we subtract an 8-bit fixed point version of N from 
            the coodinates in order to put the origin at the center of 
            the canvas. This allows us to rotate these coordinates 
            without additional shifts beforehand */
            map[index*2  ] = x2-N2*MAPFIXEDP;
            map[index*2+1] = y2-N2*MAPFIXEDP;
        }
    }
    var buff1 = new Uint32Array( N*N + 1);
    var buff2 = new Uint32Array( N*N + 1);

    offsetx  = 0;
    offsety  = 0;
    costheta = 0;
    sintheta = 0;
        
    var buf  = new ArrayBuffer(imageData.data.length);
    var buf8 = new Uint8ClampedArray(buf);
    var data = new Uint32Array(buf);
    
    var huetic = 0;
    
    function render() {
        
        /* Load the cursor locations and set the camera parameters 
        accordingly*/
        y1 = cursor1.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x1 = cursor1.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        offsetx = -x1*16;
        offsety = -y1*16;
        
        y2 = cursor2.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x2 = cursor2.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        mouseTheta  = Math.atan2(x2,y2);
        mouseRadius = Math.round(256*256/Math.sqrt(x2*x2+y2*y2));/* what is this for? */
        costheta    = Math.cos(mouseTheta)*mouseRadius;
        sintheta    = Math.sin(mouseTheta)*mouseRadius;
        
        /* We seed a weak RNG with a strong RNG. This gives us good speed
         and also decent randomness */
        //var rand = Math.floor(Math.random()*0x1000000);
        
        var writeindex = 0;
        for (var y = 0; y < N; ++y)
        for (var x = 0; x < N; ++x) {
            var index  = y*N + x;
            var x2 = map[index*2  ] + offsetx;
            var y2 = map[index*2+1] + offsety;
            /* Using 8-bit fixed point, apply a rotation to x2 and y2 */
            /* After the rotation, apply the offset */
            var x3 = (costheta * x2 + sintheta * y2 >> 8) + N2*MAPFIXEDP;
            var y3 = (costheta * y2 - sintheta * x2 >> 8) + N2*MAPFIXEDP;
            var xi = x3>>4;
            var yi = y3>>4;
            var xf = x3 & 0xf;
            var yf = y3 & 0xf;
            var xj = xi;
            var yj = yi;
            while (xj< 0) xj+=W;
            while (xj>=W) xj-=W;
            while (yj< 0) yj+=H;
            while (yj>=H) yj-=H;
            var colorA = buff1[(xj+yj*W)];
            xj += 1;
            while (xj< 0) xj+=W;
            while (xj>=W) xj-=W;
            while (yj< 0) yj+=H;
            while (yj>=H) yj-=H;
            var colorB = buff1[(xj+yj*W)];
            yj += 1;
            while (xj< 0) xj+=W;
            while (xj>=W) xj-=W;
            while (yj< 0) yj+=H;
            while (yj>=H) yj-=H;
            var colorD = buff1[(xj+yj*W)];
            xj -= 1;
            while (xj< 0) xj+=W;
            while (xj>=W) xj-=W;
            while (yj< 0) yj+=H;
            while (yj>=H) yj-=H;
            var colorC = buff1[(xj+yj*W)];
            
            var colorE = (((colorA<<4)+(colorB-colorA)*xf>>4)+ROUNDER) & 0xf0f0f0;
            var colorF = (((colorC<<4)+(colorD-colorC)*xf>>4)+ROUNDER) & 0xf0f0f0;
            var color  = ((colorE<<4)+(colorF-colorE)*yf>>4) ;
            //if (xi>=0 && yi>=0 && xi<N && yi<N) {
            
            if (xi>=0 && yi>=0 && xi<N && yi<N) {
                //color >>= 1;
                //color &= 0x7f7f7f;
                //color = (colormap[huetic]+(color&0xfefefe))>>1;
            } 
            else {
                color = (colormap[huetic]+3*(color&0xfcfcfc))>>2;
            }
			//rand ^= rand>>2^rand<<1;
			//color &= 0xf0f0f0;
			//color = (color<<4)+((rand&0xf0f0f0)-color)*noise_beta >> 4 & 0xf0f0f0;
			color = 0xff000000|color&0xf0f0f0;
            data[writeindex] = color;
            buff2[writeindex] = color;
            writeindex ++;
        }
        
        /* blit to screen */
        imageData.data.set(buf8);
        ctx.putImageData(imageData, 0, 0);
        
        var temp = buff2;
        buff2 = buff1;
        buff1 = temp;
        
        huetic = (huetic+13)&0xff;
        
        /** Apparently animations loops live in the event thread like so*/
        setTimeout(render, 0);
    }
    
    print('starting');
    /** Apparently animations loops live in the event thread like so*/
    setTimeout(render, 0);
}

</script>

</body>
</html>
