<html>
<head>

<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
.item { 
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -o-user-select: none;
    user-select: none;
}
</style>

</head>
<body onload="perceptron()">
<a href="index.html">&#8606; </a></br>
<center>
<canvas id="canvas" width="1" height="1">Sorry, your browser does not support JavaScript canvas, or it is disabled.</canvas>
</center>

<script type="application/javascript">

/** As far a I can tell this is how you do println in Javascript? */
function print(msg){setTimeout(function(){throw new Error(msg);},0);}

function perceptron(){

    var N  = 512; /* Screen size */
    var N2 = N/2;
    var MAPFIXEDP = 16;

    /* prepare canvas */
    var canvas = document.getElementById('canvas');
    canvas.width  = N; 
    canvas.height = N; 
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, N, N);
    canvas.onselectstart = function(){return false;}
    canvas.className = "item"

    /* prepare cursors */
    cursor_radius = 10;
    var cursor1 = document.createElement("div");
    document.body.appendChild(cursor1);
    cursor1.style['border-radius']='50%';
    cursor1.style.background='#0F0';
    cursor1.style.position='absolute';
    cursor1.style.width  = 2*cursor_radius;
    cursor1.style.height = 2*cursor_radius;
    cursor1.style.top    = canvas.offsetTop+N2;
    cursor1.style.left   = canvas.offsetLeft+N2;
    cursor1.onselectstart = function(){return false;}
    cursor1.className = "item"
    
    var cursor2 = document.createElement("div");
    document.body.appendChild(cursor2);
    cursor2.style['border-radius']='50%';
    cursor2.style.background='#F00';
    cursor2.style.position='absolute';
    cursor2.style.width  = 2*cursor_radius;
    cursor2.style.height = 2*cursor_radius;
    cursor2.style.top    = canvas.offsetTop+100;
    cursor2.style.left   = canvas.offsetLeft+N2;
    cursor2.onselectstart = function(){return false;}
    cursor2.className = "item"
    
    print('cursors generated');
    
    /* Prepare cursor interactivity hooks */
    var cursor_selected = null;
	document.onmouseup  = function(e) {cursor_selected = null;}
    cursor1.onmousedown = function(e) {cursor_selected = cursor1;}
    cursor2.onmousedown = function(e) {cursor_selected = cursor2;}
	document.onmousemove = function(e) {
		if (cursor_selected) {
			var x = e.pageX-canvas.offsetLeft;
			var y = e.pageY-canvas.offsetTop;
			x = Math.min(N-cursor_radius,x);
			y = Math.min(N-cursor_radius,y);
			x = Math.max(cursor_radius,x);
			y = Math.max(cursor_radius,y);
			cursor_selected.style.top  = y + canvas.offsetTop  - cursor_radius;
			cursor_selected.style.left = x + canvas.offsetLeft - cursor_radius;
		}
	}
    
    /* prepare recurrence map */
    var map  = new Int32Array( N*N*2 );
    for (var y = 0; y < N; ++y) {
        for (var x = 0; x < N; ++x) {
            var real   = (x-N2)*4.0/N;
            var imag   = (y-N2)*4.0/N;
            var real2  = 0.5*(real*real-imag*imag);
            var imag2  = 0.5*(2*real*imag);
            var x2     = Math.round((real2*N/4+N2)*MAPFIXEDP);
            var y2     = Math.round((imag2*N/4+N2)*MAPFIXEDP);
            var index  = y*N + x;
            /* Note: we subtract an 8-bit fixed point version of N from 
            the coodinates in order to put the origin at the center of 
            the canvas. This allows us to rotate these coordinates 
            without additional shifts beforehand */
            map[index*2  ] = x2-N2*MAPFIXEDP;
            map[index*2+1] = y2-N2*MAPFIXEDP;
        }
    }
    var buff1 = new Uint32Array( N*N + 1);
    var buff2 = new Uint32Array( N*N + 1);

    offsetx  = 0;
    offsety  = 0;
    costheta = 0;
    sintheta = 0;
        
    noise_level = 2;
	noise_beta  = noise_level;
	noise_alpha = 16 - noise_beta;
		
    var buf  = new ArrayBuffer(imageData.data.length);
    var buf8 = new Uint8ClampedArray(buf);
    var data = new Uint32Array(buf);
    
    function render() {
        
        /* Load the cursor locations and set the camera parameters 
        accordingly*/
        y1 = cursor1.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x1 = cursor1.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        offsetx = -x1*16;
        offsety = -y1*16;
        
        y2 = cursor2.offsetTop -canvas.offsetTop -N2+cursor_radius;
        x2 = cursor2.offsetLeft-canvas.offsetLeft-N2+cursor_radius;
        mouseTheta  = Math.atan2(x2,y2);
        mouseRadius = Math.round(256*256/Math.sqrt(x2*x2+y2*y2));/* what is this for? */
        costheta    = Math.cos(mouseTheta)*mouseRadius;
        sintheta    = Math.sin(mouseTheta)*mouseRadius;
        
        /* We seed a weak RNG with a strong RNG. This gives us good speed
         and also decent randomness */
        var rand = Math.floor(Math.random()*0x1000000);
        
        var writeindex = 0;
        for (var y = 0; y < N; ++y)
        for (var x = 0; x < N; ++x) {
            var index  = y*N + x;
            var x2 = map[index*2  ] + offsetx;
            var y2 = map[index*2+1] + offsety;
            /* Using 8-bit fixed point, apply a rotation to x2 and y2 */
            /* After the rotation, apply the offset */
            var x3 = (costheta * x2 + sintheta * y2 >> 8) + N2*MAPFIXEDP;
            var y3 = (costheta * y2 - sintheta * x2 >> 8) + N2*MAPFIXEDP;
            var xi = x3>>4;
            var yi = y3>>4;
            var xf = x3 & 0xf;
            var yf = y3 & 0xf;
            var index = xi+yi*N;
            var colorA = buff1[index    &0x3ffff];
            var colorB = buff1[index  +1&0x3ffff];
            var colorC = buff1[index+N  &0x3ffff];
            var colorD = buff1[index+N+1&0x3ffff];
            var colorE = (colorA<<4)+(colorB-colorA)*xf >> 4 & 0xf0f0f0;
            var colorF = (colorC<<4)+(colorD-colorC)*xf >> 4 & 0xf0f0f0;
            var color  = (colorE<<4)+(colorF-colorE)*yf >> 4 ;
            color = (xi>=0 && yi>=0 && xi<N && yi<N)? ~color:(color>>1)&0x7f7f7f;
			rand ^= rand>>2^rand<<1;
			color &= 0xf0f0f0;
			color = (color<<4)+((rand&0xf0f0f0)-color)*noise_beta >> 4 & 0xf0f0f0;
			
			color = 0xff000000|color&0xf0f0f0;
            data[writeindex] = color;
            buff2[writeindex] = color&0xf0f0f0;
            writeindex ++;
        }
        
        /* blit to screen */
        imageData.data.set(buf8);
        ctx.putImageData(imageData, 0, 0);
        
        var temp = buff2;
        buff2 = buff1;
        buff1 = temp;
        
        /** Apparently animations loops live in the event thread like so*/
        setTimeout(render, 0);
    }
    
    /** Apparently animations loops live in the event thread like so*/
    setTimeout(render, 0);
}

</script>

</body>
</html>
