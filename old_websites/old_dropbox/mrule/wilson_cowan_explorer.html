<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<title>Flicker</title>
<!-- Flicker javascript demo (c) Michael Rule 2015 --> 
<link rel="stylesheet" type="text/css" href="wce_style.css">

<!-- import the MathJax scripts -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-64211605-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- color maps are stored in a separate file -->
<script type="text/javascript"
  src="./colormaps.js">
</script>

</head>
<body>

<!-- automatic detection of machine archetecture / speed is tricky
     (what if you detect the wrong one! how is the use to correct it?)
     So we simply provide some options for the speed / resolution 
     trade-offs of the simulation, prompting the user to select -->
<div class="overlay" style="margin:auto auto; height:100%; width:100%; font-size:80%; z-index:1500;" id="resframe">
    <div class="outer">
        <div class="middle">
            <center>
            Select the resolution best for your machine</br>
            Currently, some presets only work at fine resolution or higher</br>
            </br>
            <div class="resbutton" onclick="javascript:waitForMathJax(3)">Course/Fast (Tablet)</div>
            <div class="resbutton" onclick="javascript:waitForMathJax(2)">Default (Laptop)</div>
            <div class="resbutton" onclick="javascript:waitForMathJax(1)">Fine (Desktop)</div>
            <div class="resbutton" onclick="javascript:waitForMathJax(0)">Finest (Workstation)</div>
            </center>
        </div>
    </div>
</div>

<!-- sometimes, MathJax takes a moment to load. While mathJax is loading, 
     components of the UI will redraw and also resize and move around. To
     hide this from the user, we cover everything with a loading div, which
     waits until MathJax is loaded. In most cases, MathJax will have loaded
     in the background while the user is selecting simulation resolution. 
     Still, we have this screen as a fallback just in case -->
<div class="overlay" style="margin:auto auto; height:100%; width:100%; font-size:80%;" id="hidingframe">
    <div class="outer">
        <div class="middle">
            <center>
            Please wait while the simulation loads<br/>
            This page requires JavaScript and access to the MathJax servers.<br/><br/>
            <img src="loader.gif"/>
            </center>
        </div>
    </div>
</div>

<!-- I didn't want the simulation to start automatically, so I require user
     click to get things going. I need to rethink this. I should probably
     have the clickblocker just over the simulation area, so that the
     UI controls aren't also blocked -->
<div class="clickblocker" style="margin:auto auto; height:100%; width:100%;" id="clickblock">
</div>

<div class="outer" id="mainframe">
<div class="middle">
<div id='canvasdiv'>
    <div class="controlbox" style="font-size:85%;position:relative;">
        <!-- parameters for the neural field model. 
             wouldn't it be nice if we could auto-generate this from a 
             template, so that other models like reaction diffusion could
             be created quickly? -->
        <div style="clear:both;display:block">
            <div class="controls">
                Inhibitory
                <div class="control"><span class="eqn">$a_{ie}$     </span><input type="number" step="any" max="100"  min="0"    name="Aie" value="12.0"/></div>
                <div class="control"><span class="eqn">$a_{ii}$     </span><input type="number" step="any" max="100"  min="0"    name="Aii" value="3.0"/></div>
                <div class="control"><span class="eqn">$\gamma_{ie}$</span><input type="number" step="any" max="100"  min="0"    name="Gie" value="0.0"/></div>
                <div class="control"><span class="eqn">$\gamma_{ii}$</span><input type="number" step="any" max="100"  min="0"    name="Gii" value="0.0"/></div>
                <div class="control"><span class="eqn">$\tau_i$     </span><input type="number" step="any" max="1000" min="0"    name="Ti"  value="20.0"/></div>
                <div class="control"><span class="eqn">$\theta_i$   </span><input type="number" step="any" max="100"  min="-100" name="Hi"  value="3.5"/></div>
                <div class="control"><span class="eqn">$g_i$        </span><input type="number" step="any" max="100"  min="-100" name="Gi"  value="0.0"/></div>
                <div class="control"><span class="eqn">$\sigma_i$   </span><input type="number" step="any" max="100"  min="0"    name="Si"  value="1.5"/></div>
                <div class="control"><span class="eqn">$n_i$        </span><input type="number" step="any" max="100"  min="-100" name="Ni"  value="0.0"/></div>
                <div class="control"><span class="eqn">$\alpha_i$   </span><input type="number" step="any" max="1000" min="0"    name="ai"  value="5.0"/></div>
                <div class="control"><span class="eqn">$\beta_i$    </span><input type="number" step="any" max="100"  min="-100" name="bi"  value="0.0"/></div>
            </div>
            <div class="controls">
                Excitatory
                <div class="control"><span class="eqn">$a_{ee}$     </span><input type="number" step="any" max="100"  min="0"    name="Aee" value="10.0"/></div>
                <div class="control"><span class="eqn">$a_{ei}$     </span><input type="number" step="any" max="100"  min="0"    name="Aei" value="8.5"/></div>
                <div class="control"><span class="eqn">$\gamma_{ee}$</span><input type="number" step="any" max="100"  min="0"    name="Gee" value="0.0"/></div>
                <div class="control"><span class="eqn">$\gamma_{ei}$</span><input type="number" step="any" max="100"  min="0"    name="Gei" value="0.0"/></div>
                <div class="control"><span class="eqn">$\tau_e$     </span><input type="number" step="any" max="1000" min="0"    name="Te"  value="10.0"/></div>
                <div class="control"><span class="eqn">$\theta_e$   </span><input type="number" step="any" max="100"  min="-100" name="He"  value="2.0"/></div>
                <div class="control"><span class="eqn">$g_e$        </span><input type="number" step="any" max="100"  min="-100" name="Ge"  value="0.8"/></div>
                <div class="control"><span class="eqn">$\sigma_e$   </span><input type="number" step="any" max="100"  min="0"    name="Se"  value="0.6"/></div>
                <div class="control"><span class="eqn">$n_e$        </span><input type="number" step="any" max="100"  min="-100" name="Ne"  value="0.0"/></div>
                <div class="control"><span class="eqn">$\alpha_e$   </span><input type="number" step="any" max="1000" min="0"    name="ae"  value="5.0"/></div>
                <div class="control"><span class="eqn">$\beta_e$    </span><input type="number" step="any" max="100"  min="-100" name="be"  value="0.0"/></div>
            </div>
        </div>
        <br>
        <div style="clear:both;display:block">
            <div class="controls" style="width:200px;">
                Time stepping
                <div class="control"><span class="eqn">$\Delta t$</span><input type="number" step="any" max="100"  min="0"    name="dt"  value="2.0"/></div>
                <div class="control">Skip<input type="number" step="1" max="50"  min="1"    name="display_every"  value="1"/></div>
            </div>
            <!-- We're replacing the stimulus with a more general user supplied stimulus function
                 So these stimulus control parameters are now obsolete-->
            <div class="controls">
                Stimulus
                <div class="control"><span class="eqn">$A$       </span><input type="number" step="any" max="100"  min="-100" name="A" value="0.5"/></div>
                <div class="control"><span class="eqn">$T$       </span><input type="number" step="any" max="1000" min="0"    name="T"   value="50.0"/></div>
            </div>
            <!---->
        </div>       
        
        <!-- buttons that control the simulation start/stop etc -->
        <!-- need to set up a separate div here to make this one 
             align with the bottom of the region -->
        <div style="position:absolute;bottom:0;left:0;">
            <div class="controltext" style="width:240px;">
                Simulation
            </div>
            <div class="button_container">
                <input class="button" type="button" value="Start"/>
                <input class="button" type="button" value="Step"/>
                <input class="button" type="button" value="Save"/>
                <input class="button" type="button" value="Load"/>
                <input class="button" type="button" value="Randomize"/>
                <input class="button" type="button" value="Seed"/>
            </div>
        </div>
    </div>
    
    <!-- main canvas in which we will be running and displaying the sim -->
    <div style="position:relative;">
    <canvas id='maincanvas' style="position:absolute; left:200px; z-index: 1;">
    This application relies on the HTML5 Canvas element and Javascript. 
    If you have Javascript disabled, try re-enabling it for this page.
    </canvas>
    <div id='canvasoverlay' style="position:absolute; left:200px; z-index: 2;">
        <div style="display: table-cell; vertical-align: middle;">
        Click to start
        </div>
    </div>
    </div>
    
    <!-- right side information and controls -->
    <div class="infotext"  style="font-size:85%;position:relative;height:512px;">
        <h3 style="margin-top:0px;">Wilson-Cowan Explorer</h3>
    	Wilson Cowan E-I equations, with adaptation and noise.
        <br/><br/>
        This page uses <a href="http://www.mathjax.org">MathJax</a> 
        to render $\LaTeX$ equations.
        <br/><br/>
        <span id="colormapinfo">The E-cell firing rate is represented as yellow and the I-cell firing rate as blue.</span>
        <br/><br/>    
        <span style="font-size:80%;">©2015 Michael Rule all rights reserved</span>
        <br/><br/>
            
        <!-- need to set up a separate div here to make this one 
             align with the bottom of the region -->
        <div style="position:absolute;bottom:-6px;right:0;margin:5px;width:190px;">
            <div class="controltext">Presets</div>
            <div class="button_container" id="funpresets"></div>  
	
	        <div style="display:none;" id="colorpanel">
                <div class="controltext" style="width:240px;">
                    Color options
                </div>
                <div class="button_container">
                    <input class="button" type="button" value="Yellow Blue"/>
                    <input class="button" type="button" value="Red Green"/>
                    <input class="button" type="button" value="Map 1"/>
                    <input class="button" type="button" value="Map 2"/>
                </div>
            </div>
        </div>
        
    </div>
    
    <!-- user supplied functions -->
    <div style="font-size:90%;">
    </br>
    <div class="controltext">
        Stimulus($x$,$y$,$t$) <span class="eqn" style="font-size:85%;">${}=\textrm{Stim}(x,y)\cdot\textrm{Stim}(t)$</span>
    </div>
    <div class="control"><span class="eqn" style="font-size:89%;padding-right:-13px;margin-right:-13px;">$\textrm{Stim}(t)={}$</span>
        <input type="text" value="heav(sin(2*PI*t/T)-0.8)*A" id="tstim"  style="width:800px;font-size:89%;"/></div>
    <div class="control"><span class="eqn" style="font-size:89%;padding-right:-13px;margin-right:-13px;">$\textrm{Stim}(x,y)={}$</span>
        <input type="text" value="1"                         id="xystim" style="width:800px;font-size:89%;" title="x and y are in units of pixels, and the origin is at the center"/></div>
    </div>
      
      
    <!-- display of model equations -->
    <div id="equation">
    \[
    \begin{align}
    \tau_e \dot{U_e} &= -U_e + f( a_{ee}  \cdot K_e \star U_e - a_{ie}  \cdot K_i \star U_i - \theta_e + g_e S(t) + n_e\cdot\mathrm{noise} - \beta_e A_e + \gamma_{ee} \overline{U_e} + \gamma_{ie} \overline{U_i})
    ,&\,&
    \alpha_e \dot{A_e} = -A_e + U_e \\
    \tau_i \dot{U_i} &= -U_i + f( a_{ei}  \cdot K_e \star U_e \,- a_{ii}  \cdot K_i \star U_i - \theta_i \,+ g_i S(t) \,+ n_i\cdot\mathrm{noise} \,- \beta_i A_i
     + \gamma_{ie} \overline{U_e} \, + \gamma_{ii} \overline{U_i})
    ,&\,&
    \alpha_i \dot{A_i} = -A_i + U_i
    \end{align}
    \]
    \[
    K_{e,i}(x)=\frac{1}{\sigma_{e,i} \sqrt{2\pi}} \exp({{\mid x\mid^2} / 2\sigma_{e,i}^2})\]
    </div>

    
</div>
</div>
</div>

<script type="text/javascript" src="./gaussian_convolution.js"></script> 
<script type="text/javascript" src="./sprintf.js"></script> 

<script type="text/javascript">
function main(downscale) {
    
	// step function
	function heav(x) { return 1.0*(x>0); }
	
	// firing nonlinearity
	// function F(x) { return 1.0*(x>0); }
	function F(x) { return 0.5*(
	    1+x/(1+Math.abs(x))
	    ); }
	//function F(x) { return 1/(1+Math.exp(-x)); }
	    
    /* 
	Prepare rendering canvas 
	
	The canvas element and the div that contains it are identified by Id
	
	There is a scaling factor betAeen the size of the image buffer that backs
	the canvas, and the actual displayed size of the canvas. These computations
	are very expensive, so we run the simulation at a resolution that is 
	courser than the display.
	
	The downscale variable is a power of 2. So a downscale value of "2" 
	corresponds to a scaling factor of 4. 
	
	We exctract the canvas context and the image data object from that
	context. We use the context to blit pixels to the canvas later. 
	
	The image data is a byte packed int32 ARGB format. We create a Uint32
	"view" of this data buffer which can be accessed as an array "data". 
	
	This image buffer is initialized with a checkerboard pattern to verify 
	that everything is properly configured.
	*/
    var canvas = document.getElementById('maincanvas');
    var frame  = document.getElementById('canvasdiv');
	
    var W  = canvas.clientWidth >>downscale;
    var H  = canvas.clientHeight>>downscale;
    canvas.width  = W;
    canvas.height = H;
	
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0,0,W,H);
    var data = new Uint32Array(imageData.data.buffer);
	
    for (var y=0;y<H;y++)
        for (var x=0;x<W;++x)
            data[x+W*y] = 0xff000000 | ((x^y)&1)*0xffffff;
    ctx.putImageData(imageData, 0, 0);     
    
    
	/* 
	Prepare data structures for simulation
	
	We do not use the image display buffer for simulation. The simulation 
	is the usual two-population laterally coupled Wilson-cowan equations.
	
	Te dUe/dt = -Ue + F(Aee•Ue-Aei•Ui+Je(t)+He)
	Ti dUi/dt = -Ui + F(Aie•Ue-Aii•Ui+Ji(t)+Hi)
	F(x) = 1/(1+exp(-a(x-b)))
	
	<•> is convolution, Aee Aei Aie Aii are 2D Gaussian kernels with
	standard deviation S. The excitatory and inhibitory spreads 
	are the same for both types of connections, i.e. Se=Sei, Sie=Si
	Also, Se > Si. The excitatory spread is larger than the 
	inhibitory. 
	
	The parameters a and b can be absorbed into rescalings of the
	coupling Aeights W and adjustment of biase terms H
	
	J is an external time and space varying input
	
	We need four buffers to model this system. For each of the E and I
	population we need a buffer to store the current values Ue and Ui
	and also a buffer to store the intermediate results of a 
	convolution, defining the lateral connectivity. Buffers are
	initialized by number of bytes, and float32s take up 4 butes.
	*/

	var dt  = 1.0;     // Euler integrator time step
	var Te  = 10;      // Excitatory population time constant (ms)
	var Ti  = 20;      // Inhibitory population time constant (ms)
	var Se  = 0.8;     // Excitatory population spread (standard deviations)
	var Si  = 2.5*Se;  // Inhibitory population spread (standard deviations)
	var Aee = 10.0;    // E-E coupling Aeight
	var Aie = 12;      // Excitation of Inhibitory coupling Aeight
	var Aei = 8.5;     // Inhibition of Excitatory coupling Aeight
	var Aii = 3.0;     // I-I coupling Aeight
	var Gee = 0;       // E-E coupling Aeight
	var Gie = 0;       // Excitation of Inhibitory coupling Aeight
	var Gei = 0;       // Inhibition of Excitatory coupling Aeight
	var Gii = 0;       // I-I coupling Aeight
	var He  = 2.0;     // Bias in E cell synaptic input
	var Hi  = 3.5;     // Bias in I cell synaptic input
	var Ne  = 0.0;     // Noise level (uniform) in E cells
	var Ni  = 0.0;     // Noise level (uniform) in I cells
	var T   = 125.0;   // Oscillatory period (ms)
	var Ge  = 0.8;     // Input drive to E cells
	var A   = 0.7;
	var Gi  = 0.0;     // Input drive to I cells
	var Str = 0.8;     // Sinusoidal input stimulus is thresholded
	var ai  = 5.0;     // Timescale of inhibitory adaptation
	var ae  = 5.0;     // Timescale of excitatory adaptation
	var bi  = 0.0;     // Strength of Inhibitory adaptation
	var be  = 0.0;     // Strength of Excitatotu adaptation
    var stimtime = 'heav(sin(2*PI*t/T)-0.8)*A';
    var stimspace = '1';
    
	var display_every = 1; // don't show every time step
    var running = 0;
	
    /* accepting user-defined functions for the stimulus in space and
       time */
	var FStimTime ;
	var FStimSpace;
    var mask = new Float32Array(new ArrayBuffer(W*H*4));
    function updateStimulusMask(value) {
        try {
            with (Math) FStimSpace = 
                eval("(function(x,y) {return "+value+";})");
		    for (var _Y=0;_Y<H;++_Y)
                for (var _X=0;_X<W;++_X)
			        mask[_X+W*_Y] = FStimSpace(_X-W/2.0,_Y-H/2.0);
            stimspace  = value;
        } catch(err) {
            console.log('problem with stimulus mask');
        }
    }
    function updateStimulusTimeFunction(value) {
        with (Math) FStimTime = 
            eval(sprintf("(function(t) {return %s;})",value));
        stimtime   = value;
    }
    updateStimulusMask(stimspace);
    updateStimulusTimeFunction(stimtime);
	
	
	function defaults() {
	    // apply default parameter values
		// useful if a preset doesn't define all values
		dt  = 1.0;     // Euler integrator time step
		Te  = 10;      // Excitatory population time constant (ms)
		Ti  = 20;      // Inhibitory population time constant (ms)
		Se  = 0.8;     // Excitatory population spread (standard deviations)
		Si  = 2.5*Se;  // Inhibitory population spread (standard deviations)
		Aee = 10.0;    // E-E coupling Aeight
		Aie = 12;      // Excitation of Inhibitory coupling Aeight
		Aei = 8.5;     // Inhibition of Excitatory coupling Aeight
		Aii = 3.0;     // I-I coupling Aeight
		Gee = 0;       // E-E coupling Aeight
		Gie = 0;       // Excitation of Inhibitory coupling Aeight
		Gei = 0;       // Inhibition of Excitatory coupling Aeight
		Gii = 0;       // I-I coupling Aeight
		He  = 2.0;     // Bias in E cell synaptic input
		Hi  = 3.5;     // Bias in I cell synaptic input
		Ne  = 0.0;     // Noise level (uniform) in E cells
		Ni  = 0.0;     // Noise level (uniform) in I cells
		T   = 125.0;   // Oscillatory period (ms)
		Ge  = 0.8;     // Input drive to E cells
		A   = 0.7;
		Gi  = 0.0;     // Input drive to I cells
		ai  = 5.0;
		ae  = 5.0;
		bi  = 0.0;
		be  = 0.0;
        stimtime = 'heav(sin(2*PI*t/T)-0.8)*A';
        stimspace = '1';
        updateStimulusMask(stimspace);
        updateStimulusTimeFunction(stimtime);
		display_every = 1; // don't show every time step
	}
	
    var Ue   = new Float32Array(new ArrayBuffer(W*H*4));
    var Ui   = new Float32Array(new ArrayBuffer(W*H*4));
    var Ae   = new Float32Array(new ArrayBuffer(W*H*4));
    var Ai   = new Float32Array(new ArrayBuffer(W*H*4));
    var Uec  = new Float32Array(new ArrayBuffer(W*H*4));
    var Uic  = new Float32Array(new ArrayBuffer(W*H*4));
    var temp = new Float32Array(new ArrayBuffer(W*H*4));   
    
	/*
	Define a mapping from simulation space into color space.
	The nonlinarity clamps values betAeen 0 and 1, these
	can be mapped linearly to 0..255 color values
	
	Define an update function to convert simulation to 
	image data and show it.
	
	Initialize the system with a test pattern and show that
	test pattern.
	*/
    
	function sim2image() {
		/* Converts simulation data to image data for display. */
	    for (var y=0;y<H;++y) {
	        for (var x=0;x<W;++x) {
				i = x+W*y;
				data[i] = 0xff000000
	                    | ((Ue[i]*0xff)&0xff)*0x000101
	                    | ((Ui[i]*0xff)&0xff)*0x010000;
	        }
	    }
	}
	
	function showSim() {
		sim2image();
    	ctx.putImageData(imageData, 0, 0);      
    }

    for (var y=0;y<H;++y)
	for (var x=0;x<W;++x) {
		i = x+W*y;
        Ue[i] = ((x^y)&1);
        Ui[i] = 1-Ue[i];
	}
	
	showSim();
	
	/*
	Perform actual simulation initializaton. 
	
	Define the firing rate nonlinearity. 
	
	Define shared random state and Sed it. We use
	a local, very Aeek random number generator for 
	speed. We occassionally re-Sed this RNG from a 
	stronger RNG source.
	
	Initialize simulation with a random state. 
	*/
	
	var rand = Math.floor(Math.random()*0x1000000);
	function seedrand() { 
		rand = Math.floor(Math.random()*0x1000000);}
	function weakrand() { 
		return ((rand^=rand>>2^rand<<1)&0xffff) * 1.52587890625e-05;}

	 // initialization functions
	function randomize() {
        for (var y=0;y<H;++y)
	    for (var x=0;x<W;++x) {
		    var i = x+W*y;
            Ue[i] = weakrand();
            Ui[i] = weakrand();
            Ae[i] = weakrand();
            Ai[i] = weakrand();
	    }
    	showSim();
    }	
	function seed() {
        for (var y=0;y<H;++y)
	    for (var x=0;x<W;++x) {
		    var i = x+W*y;
		    var r = Math.pow((x-W/2.0)*0.9,2)+Math.pow(y-H/2.0,2);
    	    if (r<100) {
                Ue[i] = weakrand()*0.3;
                Ui[i] = 0.0;
            } else {
                Ue[i] = 0.0;
                Ui[i] = weakrand()*0.15;
            }
            Ae[i] = 0;
            Ai[i] = 0;
	    }
    }
    randomize();
    	
	/* Test the Gaussian blur code */
	blurGaussianFloat32Separable(Ue,Ue,temp,W,H,Se);
	blurGaussianFloat32Separable(Ui,Ui,temp,W,H,Si);
	showSim();
	
    /*
    Prepare the user interface controls.
    All input fields have been given names that match local variable
    names. Rather than register an input-changed callback, currently we
    just poll input fields before each simulation update. First, we
    set the values of all input fields to match the initial state of these
    local control variables.
    */   
    var tstim  = document.getElementById('tstim');
    var xystim = document.getElementById('xystim');
    
    var inputs = document.getElementsByTagName("input");
    var controls = [];
    for (var i=0; i<inputs.length; i++)
        if (inputs[i].type=='number')
            controls.push(inputs[i]);
	
    function setcontrols() {
        for (var i=0; i<controls.length; i++) {
            var control = controls[i];
            eval('control.value='+control.name);
        }
    }
	
    setcontrols();
    var buttons = [];
    var stopstartbutton; //needs to get modified so we need a handle to it
    for (var i=0; i<inputs.length; i++) {
        var button = inputs[i];
        if (button.type=='button') {
            buttons.push(button);
            button.onclick = (function(button){return function(click) {
                eval(button.value.replace(/\s/g, '').toLowerCase()+'()');
            };})(button);
            if (button.value=='Start') {
                stopstartbutton=button;
                button.style.width = button.offsetWidth;
            }
        }
    }
    function start() {
        if (!running) {running = 1; setTimeout(iterate, 0);}
	    stopstartbutton.value="Stop";
    }
    function stop() {
        if (running) running = 0;
	    stopstartbutton.value="Start";
    }
    function step() {stop();iterate();}
    function statestring() {
        var state='';
        for (var i=0; i<controls.length; i++) {
            var control = controls[i];
            state += control.name+'='+control.value+';';
        }
        return state;
    }
    function save() {
        var wasrunning = running;
        stop();
        prompt("Copy (control+C) these parameters & record them.\nThey can be reloaded using the 'Load' button.\n", statestring());
        if (wasrunning) start();
    }
    function loadstring(s) {
        eval(s);
        setcontrols();
        randomize();
        start();
    }
    function load() {
        stop();
        result = prompt("Paste saved parameters below:\n","");
        if (result) loadstring(result);
    }
	
	function yellowblue() {
		sim2image = function () {
			/* Converts simulation data to image data for display. */
		    for (var y=0;y<H;++y) {
		        for (var x=0;x<W;++x) {
					i = x+W*y;
					data[i] = 0xff000000
		                    | ((Ue[i]*0xff)&0xff)*0x000101
		                    | ((Ui[i]*0xff)&0xff)*0x010000;
		        }
		    }
		};
		showSim();
	}
	function redgreen() {
		sim2image = function () {
			/* Converts simulation data to image data for display. */
		    for (var y=0;y<H;++y) {
		        for (var x=0;x<W;++x) {
					i = x+W*y;
					data[i] = 0xff000000
		                    | ((Ue[i]*0xff)&0xff)*0x000001
		                    | ((Ui[i]*0xff)&0xff)*0x000100;
		        }
		    }
		};
		showSim();
	}
	function map1() {
		cmap = colormap1();
		sim2image = function () {
			/* Converts simulation data to image data for display. */
		    for (var y=0;y<H;++y) {
		        for (var x=0;x<W;++x) {
					i = x+W*y;
					//data[i] = 0xff000000|0xff58d6d4;//cmap[(Ue[i]+Ui[i])*127];
					data[i] = cmap[0xff&((Ue[i]+Ui[i])*127)];
		        }
		    }
		};
		showSim();
	}
	function map2() {
		sim2image = function () {
			/* Converts simulation data to image data for display. */
		    for (var y=0;y<H;++y) {
		        for (var x=0;x<W;++x) {
					i = x+W*y;
					data[i] = 0xff000000
		                    | ((Ue[i]*0xff)&0xff)*0x000101
		                    | ((Ui[i]*0xff)&0xff)*0x010000;
		        }
		    }
		};
		showSim();
	}

    flicker_presets = [];
    
    fun_presets = [
    ['Spirals'                   ,'randomize','Aei=8  ;Aii=5;Ti=12;Hi=2;Gi=0;Ni=0;Si=1;Aee=16;Aie=10;Te=1;He=4;Ge=0;Ne=0;Se=1;dt=1;A=0;T=125;'],
    ['Bumps'                     ,'randomize','Aei=8.5;Aii=3;Ti=30;Hi=3.5;Gi=0;Ni=0;Si=2.4;Aee=14;Aie=12;Te=10;He=3;Ge=0.8;Ne=0;Se=1;dt=1;A=0;T=60;'],
    ['Stripes'                   ,'randomize','Aei=8  ;Aii=5;Ti=16;Hi=4;Gi=0;Ni=0;Si=8;Aee=12;Aie=10;Te=1;He=2.5;Ge=0;Ne=0;Se=0.8;dt=1;A=0;T=125;'],
    ['Flicker Spots'             ,'randomize','Aei=8.5;Aii=3;Ti=20;Hi=3.5;Gi=0;Si=2;Aee=10;Aie=12;Te=10;He=2;Ge=0.8;Se=0.8;dt=1;A=0.7;T=125;'],
    ['Flicker Stripe I'          ,'randomize','Aei=8.5;Aii=3;Ti=20;Hi=3.5;Gi=0;Si=2;Aee=10;Aie=12;Te=10;He=2;Ge=0.8;Se=0.8;dt=1;A=0.35;T=60;'],
    ['Flicker Stripe II'         ,'randomize','Aei=8.5;Aii=3;Ti=20;Hi=3.5;Gi=0;Si=2;Aee=10;Aie=12;Te=10;He=2;Ge=0.8;Se=0.8;dt=1;A=1.50;T=50;'],
    ['Oscillating spots'         ,'randomize','Aei=40 ;Aii=16;Ti=6;Hi=3.5;Gi=0;Ni=0;Si=3;Aee=25;Aie=20;Te=1;He=2;Ge=0.8;Ne=0;Se=1;dt=.1;A=0;T=125;'],
    ['Growing'                   ,'randomize','Aei=8  ;Aii=5;Ti=16;Hi=2;Gi=0;Ni=0;Si=6;Aee=14.7;Aie=10;Te=1;He=3.8;Ge=0;Ne=0;Se=1.5;dt=1;A=0;T=125;'],
    ['Bubbles'                   ,'randomize','Aei=8.5;Aii=3;Ti=45;Hi=3.5;Gi=0;Ni=0;Si=2.4;Aee=14;Aie=12;Te=10;He=3;Ge=0.8;Ne=0;Se=1;dt=2;A=0;T=60;'],
    ['Oscillating stripes'       ,'randomize','Aei=8.5;Aii=3;Ti=45;Hi=3.5;Gi=0;Ni=0;Si=2.4;Aee=14.8;Aie=14;Te=10;He=3;Ge=0.8;Ne=0;Se=1;dt=2;A=0;T=60;'],
    ['Division'                  ,'seed'     ,'Aei=8.5;Aii=3;Ti=50;Hi=3.5;Gi=0;Si=5;Aee=14;Aie=12;Te=10;He=3.2;Ge=0.8;Se=1.5;dt=7;A=0;T=60;'],
    ['Cables'                    ,'seed'     ,'Aei=8.5;Aii=3;Ti=10;Hi=3.5;Gi=0;Si=5;Aee=14;Aie=12;Te=10;He=3.2;Ge=0.8;Se=1.5;dt=10;A=0;T=60;'],
    ['Circuit'                   ,'randomize','Aei=10 ;Aii=0;Ti=2;Hi=6;Gi=0;Si=3;Aee=15;Aie=14;Te=1;He=1;Ge=0;Se=1;dt=1;display_every=1;A=0;T=125;'],
    ['Soap bubbles fine'         ,'randomize','Aei=6.5;Aii=3;Ti=10;Hi=3.5;Gi=0;Si=1.5;Aee=14;Aie=12;Te=10;He=3.25;Ge=0.8;Se=1;dt=3;display_every=1;A=0;T=60;'],
    ['Soap bubbles course'       ,'randomize','Aei=6.5;Aii=3;Ti=10;Hi=3.5;Gi=0;Si=2.25;Aee=14;Aie=12;Te=10;He=3.29;Ge=0.8;Se=1.5;dt=8;display_every=1;A=0;T=60;'],
    ['Temporal/spatial: stripes' ,'randomize','Aei=8.5;Aii=3;Ti=40;Hi=3.5;Gi=0;Si=2.4;Aee=15;Aie=12;Te=10;He=3;Ge=0.8;Se=1;dt=2;display_every=1;A=0;T=60;'],
    ['Boil'                      ,'randomize','Aei=8.5;Aii=3;Ti=35;Hi=3.5;Gi=0;Si=2.2;Aee=15;Aie=12;Te=10;He=3;Ge=0.8;Se=1;dt=2;display_every=1;A=0;T=60;'],
    ['Fine spiral'               ,'randomize','Aei=8.5;Aii=3;Ti=45;Hi=3.5;Gi=0;Si=0.8;Aee=14;Aie=12;Te=5;He=2.5;Ge=0.8;Se=0.8;dt=1;display_every=1;A=0;T=60;'],
    ['Nucleate'                  ,'randomize','Aei=8.5;Aii=3;Ti=5;Hi=3.5;Gi=0;Si=1.25;Aee=14;Aie=12;Te=5;He=2.5;Ge=0.8;Se=0.8;dt=1;display_every=1;A=0;T=60;'],
    ['Temporal/spatial: hexagons','randomize','Aei=8.5;Aii=3;Ti=7;Hi=3.5;Gi=0;Si=1.425;Aee=14;Aie=12;Te=5;He=2.5;Ge=0.8;Se=0.8;dt=1;display_every=1;A=0;T=60;'],
    ['Space race'                ,'randomize','Aei=8.5;Aii=3;Ti=7;Hi=3;Gi=0;Si=1.6;Aee=16;Aie=12;Te=3;He=3.014;Ge=0.8;Se=1;dt=1;display_every=1;A=0;T=60;Ne=1;'],
    ['Black cables'              ,'randomize','Aei=8.5;Aii=3;Ti=7;Hi=3;Gi=0;Si=3.2;Aee=16;Aie=12;Te=3;He=2.9;Ge=0.8;Se=2;dt=1;display_every=1;A=0;T=60;'],
    ['Wigglies'                  ,'randomize','Aei=8.5;Aii=3;Ti=7;Hi=3;Gi=0;Si=3.2;Aee=16;Aie=12;Te=3;He=2.95;Ge=0.8;Se=2;dt=1;display_every=1;A=0;T=60;'],
    ['Coral'                     ,'seed'     ,'Aei=8.5;Aii=3;Ti=7;Hi=3;Gi=0;Si=3.2;Aee=16;Aie=12;Te=3;He=3.0225;Ge=0.8;Se=1;dt=1;display_every=1;A=0;T=60;'],
    ['Grower'                    ,'seed'     ,'Aei=8.5;Aii=3;Ti=7;Hi=3;Gi=0;Si=2.8;Aee=16;Aie=12;Te=3;He=3.0225;Ge=0.8;Se=1.5;dt=1;display_every=1;A=0;T=60;'],
    ['Seeded Bullseye'           ,'seed'     ,'Aei=12;Aii=1;Ti=1;Hi=6;Gi=0;Si=5;Aee=14.2;Aie=14;Te=10;He=2;Ge=0;Se=0.9;dt=1;display_every=1;A=0;T=125;'],
    ['Blinkers'                  ,'randomize',
    'Aie=12;Aii=3;Ti=35;Hi=3.5;Gi=0;Si=2.2;Ni=0;ai=5;bi=0;Aee=15;Aei=8.5;Te=10;He=3.8;Ge=0.8;Se=1;Ne=5;ae=5;be=0;dt=2;display_every=1;A=0;T=60;'],
    ['Flicker and spots'         ,'randomize',
    'Aie=12;Aii=3;Ti=20;Hi=3.5;Gi=0;Si=2;Ni=0;ai=500;bi=1;Aee=14;Aei=8.5;Gei=9;Te=10;He=2.9;Ge=0.8;Se=0.8;Ne=2;ae=250;be=3;dt=.5;display_every=1;A=1.5;T=50;'],
    ['Dark waves'                ,'randomize',
    'Aie=40;Aii=16;Ti=80;Hi=4;Gi=0;Si=1;Ni=2;ai=5;bi=0;Aee=24;Aei=20;Te=10;He=3;Ge=0.8;Se=1;Ne=2;ae=5;be=0;dt=2.5;display_every=1;A=0;T=60;'],
    ['Sparkly black'             ,'randomize',
    'Aie=40;Aii=16;Gie=0;Gii=0;Ti=80;Hi=4;Gi=0;Si=1;Ni=2;ai=5;bi=0;Aee=24;Aei=20;Gee=0;Gei=5;Te=10;He=2.9;Ge=0;Se=1;Ne=5;ae=5;be=3;dt=2.5;display_every=1;A=0;T=60;']
    ];

	/*
	"I think var f = eval("function() { ... }"); will do what you want in most engines"
    */
    	
    //<input class="button" type="button" value="Division">
	//<div class="button_container" id="flickerpresets">
	//<div class="button_container" id="funpresets">
	/*
	Create the preset buttons. Flicker buttons have their name shown. 
	Fun preset buttons use a different class that displays the info string
	on the top left of the page on hover
	*/ 
	fun_preset_container     = document.getElementById('funpresets');
	for (var i=0; i<fun_presets.length; i++) {
	    var name = fun_presets[i][0];
	    var init = eval(fun_presets[i][1]);
	    var pdat = fun_presets[i][2];
        var ps = document.createElement("div");
        ps.setAttribute("class","squarebutton");
        //ps.innerHTML = '0123456789abcdefghijklmnopqrstuvwyyz'[i];
        var st = document.createElement("div");
        st.setAttribute("class","info");
        st.innerHTML = name;
        ps.appendChild(st);
	    ps.onclick   = (function(name,init,pdat){
	        return function() {
				stop();
				defaults();
				setcontrols
	            init();
                eval(pdat);
                setcontrols();
                console.log(name);
                start();
            };})(name,init,pdat);
        fun_preset_container.appendChild(ps);
	}
	
	/* 
	Run the simulation.
	We use forward Euler integration. This can introduce fairly large
	error. However, it is usually possible to choose a step size
	for which integration is at least stable. The remaining error can 
	be compensated for by adjusting the parameters to generate the right
	qualitative behavior.
	The integration step, in pseudocode, is
	For each frame
		Compute convolutions
		Compute update
		Update display
	*/
	
	function convolve() {	
		blurGaussianFloat32Separable(Ue,Uec,temp,W,H,Se);
		blurGaussianFloat32Separable(Ui,Uic,temp,W,H,Si);
	}
	
	var meanUe = 0.0;
	var meanUi = 0.0;
	function updateState(t) {	
		// Te dUe/dt = -Ue + F(Aee•Ue-Aei•Ui+Je(t)+He)
		// Ti dUi/dt = -Ui + F(Aie•Ue-Aii•Ui+Ji(t)+Hi)
		var aUe = dt/Te;
		var aUi = dt/Ti;
		var aAe = dt/ae;
		var aAi = dt/ai;
		var sumUe = 0.0;
		var sumUi = 0.0;
		var s  = FStimTime(t);
		//console.log(s);
		var Euniform = Gee*meanUe-Gei*meanUi-He-0.5*Ne;
		var Iuniform = Gee*meanUe-Gei*meanUi-Hi-0.5*Ni;
		for (var y=0;y<H;++y) 
        for (var x=0;x<W;++x) {
			var i  = x+W*y;
            var _ae = Ae[i];
            var _ai = Ai[i];
            var m   = mask[i];
			var Ve = F(Aee*Uec[i]-Aei*Uic[i]+weakrand()*Ne-be*_ae+Euniform+Ge*s*m);
			var Vi = F(Aie*Uec[i]-Aii*Uic[i]+weakrand()*Ni-bi*_ai+Iuniform+Gi*s*m);
			Ae[i] += (Ue[i] - _ae  )*aAe;
			Ai[i] += (Ui[i] - _ai  )*aAi;
			Ue[i] += (Ve    - Ue[i])*aUe;
			Ui[i] += (Vi    - Ui[i])*aUi;
			sumUe += Ue[i];
			sumUi += Ui[i];
        }
        meanUe = sumUe / (W*H);
        meanUi = sumUi / (W*H);
        if (isNaN(meanUe)||isNaN(meanUi)) {
            console.log('Numerical problem!');
            randomize();
            meanUe = 0.5;
            meanUi = 0.5;
        }
	}
	
	//http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	(function() {
    var lastTime = 0;
    var vendors = ['webkit', 'moz'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame =
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) { clearTimeout(id); };
    }());


    var timestep = 0;
	var frametime = +new Date(); // unary + is an integer cast here
    var framedelayms = 25;
	var nextframe = frametime+framedelayms;
	var frameskip = 1;
    function iterate() {
        if (running) requestAnimationFrame(iterate);

        // load the GUI state into the local variables
        // sorry about eval
        for (var i=0; i<controls.length; i++) {
            var control = controls[i];
            eval(control.name+'='+control.value);
        }
        
        // new feature: spatial and temporal stimuli can be specified as
        // arbitrary functions.
        if (xystim.value!==stimspace) updateStimulusMask(xystim.value);
        if (tstim.value !==stimtime ) updateStimulusTimeFunction(tstim.value);
        
    
		for (var i=0; i<display_every; i++) {
			seedrand();
			convolve();
			updateState(timestep*dt);
			timestep += 1;
		}
		showSim();
    }
    
	canvas.onmousedown = function(e) {
		if (running) stop();
		else start();
	};
	
    var hidingframe   = document.getElementById('hidingframe');
    var canvasoverlay = document.getElementById('canvasoverlay');
    var clickblock    = document.getElementById('clickblock');
    
	hidingframe.style.display = "none";
    clickblock.style.cursor   = "pointer";
	
	clickblock.onclick = function(e) { 
	    canvasoverlay.style.display = "none";
	    clickblock.style.display    = "none";
    	start();
	};
}

function waitForMathJax(scale) {

    var resframe = document.getElementById('resframe');
	resframe.style.display = "none";

	try{ 
		MathJax.Hub.Queue(["Typeset",MathJax.Hub]); 
    	MathJax.Hub.Queue(function(){main(scale);});
	}
	catch(e)
	{
		var eqns = document.getElementsByClassName('eqn');
		console.log('MathJax is missing, this will be messy');
		for (var i=0; i<eqns.length; i++) {
			var eq = eqns[i];
			console.log(eq.innerHTML);
			eq.style.fontSize = '50%';
			var s = eq.innerHTML+'';
			s = s.replace(/\$/g,'');
			s = s.replace(/_/g,' ');
			s = s.replace(/\\/g,'');
			s = s.replace(/{/g,'');
			s = s.replace(/}/g,'');
			s = s.replace(/\$/g,'');
			eq.innerHTML=s;
			//eq.innerHTML = eq.innerHTML.replace('$','');
			console.log(eq.style.fontSize);
		}
		main(scale); 
	}
}


</script>

</body>
</html>



