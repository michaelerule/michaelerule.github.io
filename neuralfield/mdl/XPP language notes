XPP/AUT is an X11-based application for exploring nonlinear ODE (and some PDE) dynamics via phase plane analysis.

The neuralfield project is partially overlapping this functionality, but aiming for proving templatign mechanisms to expore neural field equations to a variety of platforms for visualization, outreach, sampling, etc. 

Existing domain spectific languages for PDEs are, in my opinion

-- Too detailed, ideosyncratic: there is a large overhead for learning the syntax, because it does not resemble commonly used notations in the langauges that scientists usually use

-- Too verbose. Yes, a comprehensive PDE simulator needs syntax for describing a vast number of implementation details, boundary conditions, etc. This makes model descriptions necessarily verbose as they must specify all of this. For now, I do not need this. 


Implementing our own hacked-together DSL is ill-advised. It will only increase the proliferation of DSLs for PDE simulation. In the interest of standards, we will distill a subset of the XPP model description language and use a parser generator to implement our DSL (to replace the current ad-hoc state-space based parser). 

I've copied Bard's online XPP model files below. 
http://www.math.pitt.edu/~bard/xpp/help/xppexample.html
We won't start with the full language.

######################################################################

A few observations: 

Auxillary functions can be defined as
    function_name(parameter,list,here) = expression

User-controllable parameters are introduced with the par keyword
    Multiple parameters may be defined in one line
    par name=value,name2=value2,...
    Parameters may be referenced before they are declared

Auxiliary parameters are defined like functions, 
    but their expressions start with an exclamation point
    (don't use this syntax)

the character t is an implicit global variable acessible to 
    update equations

Initial conditions are defined in terms of expressions
    like par, multiple comma-seprated statements allowed
    init foo=expr1,bar=expr2,....

Time-update equations are marked with single quotes
    each update on it's own line
    x'=expr

There are built-in 'magic' commands for handling the XPP interface

the xp and yp variables define phase plane axis that may be bound
to any state variables, and given axes ranges.

the 'total' variable I think defines the amount of time over which
to integrate

Auxiliary variables can be defined with aux
    aux varname = expression
    these should be functions of the current state
    they are recorded to disk while the simulation runs
    they are available for plotting

There is a variable 'meth' which configures integration

there is a special function delay(varname,timedelay) to access
    historical values of a variables. 
    Implementing this requires a long buffer or approximation via
        a delay line (sloppy, experimental)
    There probably won't be enough memory to implement for 2D PDE

Skipping differento-algebraic equations for now. 
    they introduce a keyword 'solve', which we should reserve

Integro-differential equations also require a delay buffer
    Do not implements

XPP supports stochastic terms as well as. 
    VViener proesses are their own type
    Discrete continuous time markov processes are their own type
    (variables must have a type it seems)

Boundary value problems
    Don't implement. 
    reserve keyword bdry

Spatially extended systems
    It appears that e.g. u[1] === u1, u[100] === u100, etc
    so these are implemented by extending the state space
    there's a matlab-style slice syntax
    (we will use Julia/Pyhton)
    there is a special convolutional ODE integrator to exploit 
    regularity.
    
Convolution kernels
    there is the 'special' keyword
    these appear to be functions of the state that change in time
    that cannot be efficiently computed within the integration kernel
    so they are auxiliary variables that are computed outside 
    the integration kernel.

######################################################################

XPP langauage redux

# are comments. Sounds good

!name=formula
    Derived parameter. This can be translated to a #define in C-like
    languages and implemented as a new parameter in others. 
    It is a special case of an auxiliary function with no arguments
    With the appropriate parser we can statically determine whether
    the right-hand side depends on parameters and if so whether a name
    is a derived parameter or a temporary variable. With C-like the
    compiler should collapse constant subexpressions and these will
    be equivalent. With other languages derived terms may be treated
    as intermediate variables with some performance cost. Static 
    analysis and constant subtree evaluation can be added later.

" are special comments, seemingly verbs (buttons) for the user interface
    We probably want a different implementation

x(t+1) =formula
dx/dt  =formula
x'     =formula
    These all denote the time update step. I have no desire to 
    implement all of them. 

name(args)=formula
    defines a helper function
    only available inside integration kernel
    xpp has only 9 argument registers. consider sending warning if
    over 9

name=formula
    defines a temporary/intermediate variable
    only available inside integration kernel

par a=b,c=d,..
    Parameter list. XPP requires no whitespace around equals, using
    whitespace delimited parsing. We should try to relax that.

number
    A parameter that cannot be changed by the user
    This can be treated as a #define for all practical purposes

global
    A seemingly post-hoc language addon to allo discerete resets
    e.g. firing in a lif model. 
    we should implement this differently. 
    we should allow statements
    these statements would be run after integration and can effect
    arbitrary changes, including discrete updates.

init name1=val1,name2=val2
    Initial value statement
    We might have to think about this. 
    we might have to typecheck things
    we might have 0, 1, 2D variables, int and float, to consider

set
    Essentially a preset. Defines parameters, initial conditions
    Could use python/dict notation? Or keep equals? Or julia's arrow
    based map notation? 

foo[i..j]
    This is a macro in XPP. It's not suitable here, we want 1 and 2D
    systems to be their own type. It's unclear where we would declare
    this type. Maybe as a separate command. Types may be inferred
    as well, but I think this is needlessly complex. In python it 
    is natural to use numpy types. On the GPU, it is natural to
    specify a data type and then let the compiler determine the
    array size. Probably then, we will separate declaring the domain
    size from declaring ND variables. For now we are really only
    interested in 1 and 2D systems. No need to worry about 0d.
    No need to worry about mixing 1 and 2D systems.
    Still, language should not be needlesly restricted.



Specialized inputs
------------------

markov
    A CTMC variable denoted by rate transition matrix

wiener
    The standard Wiener process

special name=FUN()
    This is basically an operator multiplication of the state space 
    that occurs outside the integration kernel between timesteps.
    There are many implementations for various conditions, 
    convolutions, sparse matrices, etc. Also inbuilt options to apply
    a function to one field during convolution. For example on a
    GPU implementation this would/could either be included in the
    integrator kernel as a sum over indecies, or pharmed out to 
    specialized routines between kernel invocations on each time-step.
    I suggest replacing this with a keyword OPERATOR. The right-hand
    side then would invoke operator constructors.
e.g. 
    operator Ke=gaussianConvolution2D(sigma_e)




Support later
-------------

aux
    Auxiliary equations. Unclear where/if these would be computed
    in practice. Probably best to assume that if aux exists it is used
    and therefore treated as an auxiliary field that is updated 
    alongside the differential equations. 

Unsupported
-----------

volterra
table
name(0) = expression
bdry
0=
solve
@
%[j1..j2]
export
done

Reserved
--------

sin cos tan atan atan2 sinh cosh tanh
exp delay ln log log10 t pi if then else
asin acos heav sign ceil flr ran abs del_shft
max min normal besselj bessely erf erfc hom_bcs
arg1 ... arg9  @ $ + - / * ^ ** shift
| > < == >= <= != not \# int sum of i'

We should union this set with the inbuilt WebGL, CL, GLSL builtins

Anything not implemented in the target language should be given
a default macro/function.


######################################################################

Consider this: if we define a grammar in some common syntax, then
we can more easily port parsing across langauges,APIs,platforms

Consider future: grammar and symbolic algebra may be useful for 
setting up nonlinear spatiotemporal EP problems

The above is unlikely, it's too large a project and likley redundant
to what Microsoft is doing of late. 


UPDATE N'=formula
name(args)=formula
name=formula
par    NAME=CEXPR,NAME=CEXPR,..
number NAME=CEXPR,NAME=CEXPR,..
global {statement}
init VARIABLE=FORMULA,VARIABLE=FORMULA,...
set {NAME=CEXPR,NAME=CEXPR,..}
foo[i..j]
markov NAME NATURAL MATRIX[NATURALxNATURAL]
wiener NAME
operator Ke=gaussianConvolution2D(sigma_e)

So, there is a type system:

INT: (-)[0-9]+
CONSTANT: PI|E
NUMBER: INT|FLOAT|CONSTANT
CEXPR: NUMBER|CEXPR OPERATOR CEXPR|FUNCTION CEXPR

We need basic numeric expressions

Arithmetic:
    Expr     <- Factor AddExpr*
    AddExpr  <- ('+'/'-') Factor
    Factor   <- Primary MulExpr*
    MulExpr  <- ('*'/'/') Primary
    Primary  <- '(' Expr ')' / Number / Variable / '-' Primary
    Number   <- [0-9]+
    Variable <- identifier

I no longer feel that this is a wise idea.


######################################################################


    # wilson-cowan
    f(u)=1/(1+exp(-u))
    par aee=10,aie=8,aei=12,aii=3,ze=.2,zi=4
    par tau=1
    i_e(t)=ie0+ie1*sin(w*t)
    i_i(t)=ii0+ii1*sin(w*t)
    par ie0=0,ie1=0,w=.25
    par ii0=0,ii1=0
    init u=.1,v=.05
    u'=-u+f(aee*u-aie*v-ze+i_e(t))
    v'=(-v+f(aei*u-aii*v-zi+i_i(t)))/tau
    @ total=40
    @ xp=u,yp=v,xlo=-.1,xhi=1,ylo=-.1,yhi=1
    done

    # third.ode
    x'=y
    y'=z
    z'=x^2-a*z-b*y-c*x
    par a=1,b=2,c=3.7
    init x=1,y=0,z=0
    aux en=x^2+y^2+z^2
    @ total=200
    @ xp=x,yp=y,xlo=-2,xhi=5,ylo=-4,yhi=5
    done

    # delayed logistic map
    x'=y
    y'=a*y*(1-x)
    par a=2.2
    init x=.2,y=.2
    # set method to discrete
    @ meth=discrete
    @ total=100
    @ ylo=-.1,yhi=1,xhi=100
    done


    # mackey-glass
    f(x)=x/(1+x^n)
    x'=-g*x+b*f(delay(x,d))
    init x=.2
    par g=.1,b=.2,n=10,d=6
    @ delay=20
    @ total=200
    @ xhi=200,yhi=2
    done

    # dae.ode
    x'=z
    z'=y
    0=x+z+y+y^3
    solve y=-1
    init x=2
    aux ys=y
    @ yhi=2.5
    done

    # volterra example 1
    u(t)=sin(t)+.5*cos(t)-.5*t*exp(-t)-.5*exp(-t)+int{(t-t')*exp(t'-t)*u} 
    aux utrue=sin(t)
    done

    #  volt2.ode - uses convolution to speed up soln
    u(t)=sin(t)+.5*cos(t)-.5*t*exp(-t)-.5*exp(-t)+int{t*exp(-t)#u}
    aux utrue=sin(t)
    done

    # nonlinear integrodifferential volterra equation
    u'=-2*u+exp(-2*t)+int{exp(-t)#u^2}
    init u=1
    aux utrue=exp(-t)
    done

    # singular integral equation
    u(t)=exp(-t)-int[.25]{exp(-t)#sin(u)}
    done

    # a simple thermal ratchet
    wiener w
    par a=.8,s=.05,r0=.1,r1=.1
    f(x)=if(x<a)then(-1)else(a/(1-a))
    x'=z*f(mod(x,1))+s*w
    # z is two states
    markov z 2
    {0} {r0}
    {r1} {0}
    @ meth=euler,dt=.1,total=2000,nout=10
    @ xhi=2000,yhi=8,ylo=-8
    done

    # tyson.ode
    init u=.0075,v=.48,m=1
    p k1=.015,k4=200,k6=2,a=.0001,b=.005
    u'=  k4*(v-u)*(a+u^2) - k6*u
    v'= k1*m - k6*u
    m'= b*m
    global 1 {0.2-u} {m=.5*m}
    @ total=1000,nout=10
    @ yp=m,xhi=1000,ylo=0,yhi=2 
    done

    # nonlinear boundary value problem
    u'=v
    v'=sin(t*u)
    bdry u-1
    bdry u'
    init u=1,v=-1
    @ total=2,bell=0,xhi=2
    done

    # schnakenberg PDE 100 points
    f(u,v)=-u+v*u^2
    g(u,v)=a-v*u^2
    u0'=f(u0,v0)+duh*(u1-u0)
    u[1..99]'=f(u[j],v[j])+duh*(u[j+1]-2*u[j]+u[j-1])
    u100'=f(u100,v100)+duh*(u99-u100)
    v0'=g(u0,v0)+dvh*(v1-v0)
    v[1..99]'=g(u[j],v[j])+dvh*(v[j+1]-2*v[j]+v[j-1])
    v100'=g(u100,v100)+dvh*(v99-v100)
    par a=1.05,du=.2,dv=3,h=.2
    !duh=du/(h*h)
    !dvh=dv/(h*h)
    init u0=1.5,u1=1.3,u2=1.1,v0=1.05,v1=1.05,v2=1.05
    init u[3..100]=1.05,v[j]=1.05
    @ dt=.1,nout=50,total=50,meth=cvode,tol=1e-5,atol=1e-5
    done

    # schnakenberg PDE 100 points
    # interlaced
    f(u,v)=-u+v*u^2
    g(u,v)=a-v*u^2
    u0'=f(u0,v0)+duh*(u1-u0)
    v0'=g(u0,v0)+dvh*(v1-v0)
    %[1..99]
    u[j]'=f(u[j],v[j])+duh*(u[j+1]-2*u[j]+u[j-1])
    v[j]'=g(u[j],v[j])+dvh*(v[j+1]-2*v[j]+v[j-1])
    %
    u100'=f(u100,v100)+duh*(u99-u100)
    v100'=g(u100,v100)+dvh*(v99-v100)
    par a=1.05,du=5,dv=75,h=.2
    !duh=du/(h*h)
    !dvh=dv/(h*h)
    init u0=1.5,u1=1.3,u2=1.1,v0=1.05,v1=1.05,v2=1.05
    init u[3..100]=1.05,v[j]=1.05
    @ dt=.1,nout=50,total=50,meth=cvode,tol=1e-5,atol=1e-5
    @ bandlo=2,bandup=2
    done

    # Wilson-Cowan network
    table we % 51 -25 25 .5*exp(-abs(t)/se)/se
    table wi % 51 -25 25 .5*exp(-abs(t)/si)/si
    special ke=conv(even,201,25,we,u0)
    special ki=conv(even,201,25,wi,v0)
    par se=4,si=2.5
    f(u)=1/(1+exp(-u))
    par aee=16,aie=10,aei=25,aii=3,ze=4,zi=10
    par tau=4
    init u[0..4]=1
    u[0..200]'=-u[j]+f(aee*ke([j])-aie*ki([j])-ze)
    v[0..200]'=(-v[j]+f(aei*ke([j])-aii*ki([j])-zi))/tau
    @ total=60,meth=qualrk,dt=.25
    @ yp=u100,xhi=60,ylo=0
    @ yp2=u150,nplot=2
    done


